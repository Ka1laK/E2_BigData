library("askpass", lib.loc="C:/Users/risse/AppData/Local/R/win-library/4.4")
detach("package:askpass", unload=TRUE)
styler:::style_active_file()
print(Ventas_Amazon_Liberia)
install.packages("isolationForest")
setwd("~/")
setwd("~/")
setwd("C:/Users/risse/Downloads/E2_BigData")
getwd()
head(df)
df <- read.csv("dataset/diabetes.csv")
print(df)
install.packages("solitude")
library("solitude")
model <- isolationForest(df, ntree = 100,
sample_size = 256,
ExtensionLevel = 0)
model <- isolation_forest$new()
install.packages("isotree")
library(isotree)
model <- isolation.forest(df, ntrees = 100, sample_size = 256, ndim = 1)
View(model)
df <- read.csv("dataset/diabetes.csv")
library(isotree)
modelo <- isolation.forest(df, ntrees = 100, sample_size = 256, ndim = 1)
score_anomalias <- predict(modelo, df)
print(score_anomalias)
hist(score_anomalias, breaks = 30, main = "grafica")
library(ggplot2)
library(dplyr)
library(mlbench)
library(Rcpp)
library(solitude)
library(uwot)
library(tibble)
library(ggplot2)
install.packages(c("dplyr", "mlbench", "uwot"))
install.packages(c("dplyr", "mlbench", "uwot"))
library(dplyr)
library(mlbench)
library(Rcpp) # si
library(solitude) # si
library(uwot)
library(tibble) #si
library(ggplot2) #si
# getwd()
df <- read.csv("dataset/diabetes.csv")
head(df)
df_diabetes <- as_tibble(df)
head(df_diabetes)
df_diabetes <- as_tibble(df)
# install.packages(c("dplyr", "mlbench", "uwot"))
library(dplyr)
library(mlbench)
library(Rcpp) # si
library(solitude) # si
library(uwot)
library(tibble) #si
library(ggplot2) #si
df_diabetes <- as_tibble(df)
# getwd()
df <- read.csv("dataset/diabetes.csv")
# getwd()
df_init <- read.csv("dataset/diabetes.csv")
df_diabetes <- as_tibble(df_init)
head(df_diabetes)
set.seed(1)
train.sample <- sample(nrow(df_diabetes), 0.70*nrow(df_diabetes),
replace = F)
train.df <- df[train.sample,]
train.df <- df[train.sample]
head(train.sample)
df_diabetes
set.seed(1)
train.sample <- sample(nrow(df_diabetes), 0.70 * nrow(df_diabetes), replace = F)
train.df <- df_diabetes[train.sample, ]
# Crear subconjunto de prueba (30%)
test.sample <- setdiff(seq_len(nrow(df_diabetes)), train.sample)
test.df <- df_diabetes[test.sample, ]
# Verifica las primeras filas de cada subconjunto
head(train.df)
head(test.df)
t1 <- Sys.time()
t1 <- Sys.time()
iso <- isolationForest$new(
sample_size = nrow(train.df),
num_trees = 10,
max_depth = ceiling(log2(nrow(train.df)))
)
iso$fit(train.df)
Sys.time()-t1
train.df%>%
iso$predict()
train.df2 <- train.df%>%
iso$predict()%>%
arrage(desc(anomaly_score))
train.df%>%
iso$predict()%>%
arrage(desc(anomaly_score))
train.df2 <- train.df%>%
iso$predict()%>%
arrange(desc(anomaly_score))
train.df2
train.df%>%
scale()%>%
uwot::umap()
setNames(c("dimension1","dimension2"))%>%
as_tibble()
train.df %>%
scale() %>%
uwot::umap() %>%
as_tibble() %>%
setNames(c("dimension1", "dimension2"))
train.df %>%
scale() %>%
uwot::umap() %>%
as_tibble() %>%
setNames(c("V1", "V2"))
mutate(id= 1:n())
result <- train.df %>%
scale() %>%                             # Escalar los datos
uwot::umap() %>%                        # Reducir la dimensionalidad con UMAP
as_tibble() %>%                         # Convertir la salida en un tibble
setNames(c("V1", "V2")) %>%             # Renombrar las columnas
mutate(id = 1:n()) %>%                  # Agregar una columna `id` única
left_join(train.df2 %>% mutate(id = 1:n()), by = "id") # Unir con train.df2 usando `id`
plot.df <- train.df %>%
scale() %>%                             # Escalar los datos
uwot::umap() %>%                        # Reducir la dimensionalidad con UMAP
as_tibble() %>%                         # Convertir la salida en un tibble
setNames(c("V1", "V2")) %>%             # Renombrar las columnas
mutate(id = 1:n()) %>%                  # Agregar una columna `id` única
left_join(train.df2 %>% mutate(id = 1:n()), by = "id") # Unir con train.df2 usando `id`
plot.df%>%
ggplot(aes(V1,V2)) +
geom_point(aes(size = anomaly_score))
result
head(train.df)
head(test.df)
train.df2
result
head(train.df)
head(test.df)
iso
train.df2
result
train.df2
result
result
train.df2
result
train.df2
puntos_anomalos <- result %>%
filter(anomaly_score > 0.7)
print(puntos_anomalos)
puntos_anomalos %>%
ggplot(aes(V1, V2)) +
geom_point(aes(color = anomaly_score, size = average_depth)) +
ggtitle("Visualización de Puntos Anómalos en el Espacio UMAP")
puntos_anomalos
grafico.plot <- puntos_anomalos %>%
ggplot(aes(V1, V2)) +
geom_point(aes(color = anomaly_score, size = average_depth)) +
ggtitle("Visualización de Puntos Anómalos en el Espacio UMAP")
grafico.plot
grafico.plot
grafico.plot
# Obtener los IDs de los puntos anómalos
puntos_anomalos_ids <- puntos_anomalos$id
# Filtrar los puntos anómalos en el conjunto de datos original
puntos_anomalos_originales <- train.df %>%
filter(id %in% puntos_anomalos_ids)
# Imprimir los puntos anómalos con sus valores originales
print(puntos_anomalos_originales)
# Asegúrate de que 'puntos_anomalos' tiene registros
if (nrow(puntos_anomalos) > 0) {
# Obtener los IDs de los puntos anómalos
puntos_anomalos_ids <- puntos_anomalos$id
# Filtrar los puntos anómalos en el conjunto de datos original
puntos_anomalos_originales <- train.df %>%
filter(id %in% puntos_anomalos_ids)
# Imprimir los puntos anómalos con sus valores originales
print(puntos_anomalos_originales)
} else {
print("No se encontraron puntos anómalos.")
}
# Asegúrate de que 'puntos_anomalos' tiene registros y que 'id' es un vector
if (nrow(puntos_anomalos) > 0) {
# Verifica que 'id' sea un vector
puntos_anomalos_ids <- as.vector(puntos_anomalos$id)
# Filtrar los puntos anómalos en el conjunto de datos original
puntos_anomalos_originales <- train.df %>%
filter(id %in% puntos_anomalos_ids)
# Imprimir los puntos anómalos con sus valores originales
print(puntos_anomalos_originales)
} else {
print("No se encontraron puntos anómalos.")
}
# Ver las filas con los valores anómalos
train.df2 %>%
filter(anomaly_score > 0.75) # Ajusta el umbral según sea necesario
# Crear un gráfico de cajas para cada columna
train.df %>%
ggplot(aes(x = factor(0), y = Glucose)) +
geom_boxplot() +
ggtitle("Boxplot de Glucose") +
ylab("Glucose")
# Crear un gráfico de dispersión para dos variables, por ejemplo, Glucose y BMI
train.df %>%
ggplot(aes(x = Glucose, y = BMI, color = as.factor(anomaly_score > 0.75))) +
geom_point() +
ggtitle("Gráfico de dispersión de Glucose vs BMI") +
xlab("Glucose") +
ylab("BMI") +
scale_color_manual(values = c("red", "blue")) # Red para anomalías, blue para normales
# Ver las filas con los valores anómalos
train.df2 %>%
filter(anomaly_score > 0.7) # Ajusta el umbral según sea necesario
# Crear un gráfico de cajas para cada columna
train.df %>%
ggplot(aes(x = factor(0), y = Glucose)) +
geom_boxplot() +
ggtitle("Boxplot de Glucose") +
ylab("Glucose")
# Crear un gráfico de cajas para cada columna
train.df %>%
ggplot(aes(x = factor(0), y = Glucose)) +
geom_boxplot() +
ggtitle("Boxplot de Glucose") +
ylab("Glucose")
# Filtrar solo los valores anómalos en Glucose
train.df %>%
filter(anomaly_score > 0.7) %>%
ggplot(aes(x = Glucose)) +
geom_histogram(binwidth = 5) +
ggtitle("Distribución de Glucose con valores anómalos")
# Asegúrate de que la columna anomaly_score esté presente en train.df
train.df <- train.df %>%
mutate(id = 1:n()) %>%  # Asegúrate de tener la columna id en train.df
left_join(train.df2 %>% mutate(id = 1:n()), by = "id")  # Unir con train.df2 usando id
# Verifica que la columna anomaly_score está presente en train.df
head(train.df)
# Filtra los valores con anomalías (por ejemplo, anomaly_score > 0.7)
anomalies <- train.df %>%
filter(anomaly_score > 0.7)
# Realiza un análisis exploratorio con gráficos de cajas y nube de puntos para las columnas que contienen los valores anómalos
library(ggplot2)
# Gráfico de caja para columnas numéricas (por ejemplo, Glucose y BMI) donde se detectan anomalías
ggplot(anomalies, aes(x = factor(0), y = Glucose)) +
geom_boxplot() +
labs(title = "Anomalías en Glucose", x = "Anomalías", y = "Glucose")
ggplot(anomalies, aes(x = factor(0), y = BMI)) +
geom_boxplot() +
labs(title = "Anomalías en BMI", x = "Anomalías", y = "BMI")
# Gráfico de nube de puntos (por ejemplo, Glucose vs BMI) para observar la distribución de los datos anómalos
ggplot(anomalies, aes(x = Glucose, y = BMI)) +
geom_point(aes(color = anomaly_score)) +
labs(title = "Distribución de anomalías (Glucose vs BMI)", x = "Glucose", y = "BMI")
plot.df <- train.df %>%
scale() %>%                             # Escalar los datos
uwot::umap() %>%                        # Reducir la dimensionalidad con UMAP
as_tibble() %>%                         # Convertir la salida en un tibble
setNames(c("V1", "V2")) %>%             # Renombrar las columnas
mutate(id = 1:n()) %>%                  # Agregar una columna `id` única
left_join(train.df2 %>% mutate(id = 1:n()), by = "id") # Unir con train.df2 usando `id`
# Asegúrate de que la columna anomaly_score esté presente en train.df
train.df <- train.df %>%
mutate(id = 1:n()) %>%  # Asegúrate de tener la columna id en train.df
left_join(train.df2 %>% mutate(id = 1:n()), by = "id")  # Unir con train.df2 usando id
ggplot(anomalies, aes(x = factor(0), y = Glucose)) +
geom_boxplot() +
labs(title = "Anomalías en Glucose", x = "Anomalías", y = "Glucose")
ggplot(anomalies, aes(x = factor(0), y = BMI)) +
geom_boxplot() +
labs(title = "Anomalías en BMI", x = "Anomalías", y = "BMI")
# Gráfico de nube de puntos (por ejemplo, Glucose vs BMI) para observar la distribución de los datos anómalos
ggplot(anomalies, aes(x = Glucose, y = BMI)) +
geom_point(aes(color = anomaly_score)) +
labs(title = "Distribución de anomalías (Glucose vs BMI)", x = "Glucose", y = "BMI")
result
puntos_anomalos <- result %>%
filter(anomaly_score > 0.69)
print(puntos_anomalos)
puntos_anomalos <- result %>%
filter(anomaly_score > 0.7)
print(puntos_anomalos)
puntos_anomalos <- result %>%
filter(anomaly_score > 0.65)
print(puntos_anomalos)
puntos_anomalos <- result %>%
filter(anomaly_score > 0.6)
print(puntos_anomalos)
df <- read.csv(dataset/diabetes.csv)
getwd()
# Instalar y cargar librerías necesarias
if (!require(solitude)) install.packages("solitude", dependencies = TRUE)
if (!require(caret)) install.packages("caret")
if (!require(dplyr)) install.packages("dplyr")
# Cargar las librerías
library(solitude)  # Para Isolation Forest
library(caret)     # Para validación cruzada
library(dplyr)     # Para manipulación de datos
# Crear una función de evaluación personalizada
custom_scorer <- function(model, data) {
# Predecir puntajes de anomalía
predictions <- model$predict(data)
# Devolver el puntaje promedio (negativo porque caret maximiza)
return(-mean(predictions$anomaly_score))
}
# Crear una función de evaluación personalizada
custom_scorer <- function(model, data) {
# Predecir puntajes de anomalía
predictions <- model$predict(data)
# Devolver el puntaje promedio (negativo porque caret maximiza)
return(-mean(predictions$anomaly_score))
}
# Cargar los datos (reemplaza con tus datos reales)
df <- read.csv(file.choose(), sep = ",")
# Seleccionar variables de interés (por ejemplo, Glucosa y BMI)
data <- df %>% select(Glucose, BMI)
# Definir el rango de hiperparámetros a evaluar
contamination_values <- c(0.05, 0.1, 0.15, 0.2)
# Configurar la validación cruzada
cv_folds <- createFolds(1:nrow(data), k = 5, list = TRUE)
# Inicializar un data frame para almacenar resultados
results <- data.frame(contamination = double(), score = double())
# Realizar validación cruzada
for (fold in cv_folds) {
train_data <- data[-fold, ]
test_data <- data[fold, ]
# Entrenar Isolation Forest
iso_model <- IsolationForest$new(sample_size = nrow(train_data), num_trees = 100)
iso_model$fit(train_data)
# Evaluar el modelo en los datos de prueba
score <- custom_scorer(iso_model, test_data)
scores <- c(scores, score)
}
# Loop para evaluar cada valor de contamination
for (c in contamination_values) {
scores <- c()  # Almacenar puntajes por fold
# Realizar validación cruzada
for (fold in cv_folds) {
train_data <- data[-fold, ]
test_data <- data[fold, ]
# Entrenar Isolation Forest
iso_model <- IsolationForest$new(sample_size = nrow(train_data), num_trees = 100)
iso_model$fit(train_data)
# Evaluar el modelo en los datos de prueba
score <- custom_scorer(iso_model, test_data)
scores <- c(scores, score)
}
# Calcular el puntaje promedio
avg_score <- mean(scores)
# Guardar los resultados
results <- rbind(results, data.frame(contamination = c, score = avg_score))
}
for (c in contamination_values) {
scores <- c()  # Almacenar puntajes por fold
# Realizar validación cruzada
for (fold in cv_folds) {
train_data <- data[-fold, ]
test_data <- data[fold, ]
# Entrenar Isolation Forest
iso_model <- IsolationForest$new(sample_size = nrow(train_data), num_trees = 100)
iso_model$fit(train_data)
# Evaluar el modelo en los datos de prueba
score <- custom_scorer(iso_model, test_data)
scores <- c(scores, score)
}
# Calcular el puntaje promedio
avg_score <- mean(scores)
# Guardar los resultados
results <- rbind(results, data.frame(contamination = c, score = avg_score))
}
results
# Loop para evaluar cada valor de contamination
for (c in contamination_values) {
scores <- c()  # Almacenar puntajes por fold
# Realizar validación cruzada
for (fold in cv_folds) {
train_data <- data[-fold, ]
test_data <- data[fold, ]
# Entrenar Isolation Forest
iso_model <- IsolationForest$new(sample_size = nrow(train_data), num_trees = 100)
iso_model$fit(train_data)
# Evaluar el modelo en los datos de prueba
score <- custom_scorer(iso_model, test_data)
scores <- c(scores, score)
}
# Calcular el puntaje promedio
avg_score <- mean(scores)
# Guardar los resultados
results <- rbind(results, data.frame(contamination = c, score = avg_score))
}
library(solitude)
for (c in contamination_values) {
scores <- c()  # Almacenar puntajes por fold
# Realizar validación cruzada
for (fold in cv_folds) {
train_data <- data[-fold, ]
test_data <- data[fold, ]
# Entrenar Isolation Forest
iso_model <- isolationForest$new(sample_size = nrow(train_data), num_trees = 100)
iso_model$fit(train_data)
# Evaluar el modelo en los datos de prueba
score <- custom_scorer(iso_model, test_data)
scores <- c(scores, score)
}
# Calcular el puntaje promedio
avg_score <- mean(scores)
# Guardar los resultados
results <- rbind(results, data.frame(contamination = c, score = avg_score))
}
best_contamination <- results$contamination[which.min(results$score)]
print("Resultados de la validación cruzada:")
print(results)
cat("Mejor valor de contaminación:", best_contamination, "\n")
head(df)
cat("Mejor valor de contaminación:", best_contamination, "\n")
library(ggplot2)
library(gridExtra)
library(dplyr)
#################################################### parte 2
if (!require(gridExtra)) install.packages("gridExtra")
#################################################### parte 2
if (!require(gridExtra)) install.packages("gridExtra")
library(gridExtra)
# Seleccionar todas las columnas excepto la última
columns_to_plot <- colnames(df)[1:(ncol(df) - 1)]
# Crear una lista para almacenar los gráficos
plots <- list()
# Generar boxplots en un bucle
for (col in columns_to_plot) {
p <- ggplot(df, aes_string(y = col)) +
geom_boxplot(fill = "steelblue", color = "black") +
labs(title = col, y = "") +
theme_minimal()
plots[[col]] <- p
}
for (col in columns_to_plot) {
p <- ggplot(df, aes_string(y = col)) +
geom_boxplot(fill = "steelblue", color = "black") +
labs(title = col, y = "") +
theme_minimal()
plots[[col]] <- p
}
do.call(grid.arrange, c(plots, ncol = 3))
#########################################################
library(corrplot)
#########################################################
if (!require(corrplot)) install.packages("corrplot")
library(corrplot)
# Calcular la matriz de correlación
correlation_matrix <- cor(df[, sapply(df, is.numeric)], use = "pairwise.complete.obs")
corrplot(correlation_matrix, method = "color", type = "upper",
col = colorRampPalette(c("blue", "white", "red"))(200),
addCoef.col = "black", number.digits = 2,
tl.col = "black", tl.srt = 45)
ibrary(solitude)  # Para Isolation Forest
library(dplyr)     # Para manipulación de datos
library(solitude)  # Para Isolation Forest
# Seleccionar solo columnas numéricas excluyendo 'Outcome'
df_diabetes <- df %>% select(-Outcome)
# Escalar los datos
X_scaled <- as.data.frame(scale(df_diabetes))
# Mostrar las primeras filas de los datos escalados
head(X_scaled)
# Inicializar el modelo Isolation Forest
iso_model <- IsolationForest$new(sample_size = nrow(X_scaled), num_trees = 100, seed = 42)
# Inicializar el modelo Isolation Forest
iso_model <- isolationForest$new(sample_size = nrow(X_scaled), num_trees = 100, seed = 42)
# Ajustar el modelo a los datos escalados
iso_model$fit(X_scaled)
# Predecir los outliers
predictions <- iso_model$predict(X_scaled)
# Agregar las predicciones como nueva columna en el dataframe original
df$outlier <- ifelse(predictions$anomaly_score > quantile(predictions$anomaly_score, 0.8), -1, 1)
# Mostrar el dataframe con la columna 'outlier'
head(df)
###########################
library(caret)
# Convertir etiquetas del Isolation Forest
df$predicted_outlier <- ifelse(df$outlier == -1, 1, 0)
# Ver las primeras filas para confirmar
head(df)
# Generar la matriz de confusión
conf_matrix <- confusionMatrix(as.factor(df$predicted_outlier), as.factor(df$Outcome), positive = "1")
print("Matriz de Confusión:")
print(conf_matrix$table)
# Mostrar las métricas de evaluación
print("Reporte de Clasificación:")
print(conf_matrix)
#################################
library(GGally)     # Para pair plots
#################################
if (!require(GGally)) install.packages("GGally")
library(GGally)     # Para pair plots
library(ggplot2)    # Gráficos
library(dplyr)      # Manipulación de datos
# Convertir la columna 'outlier' a factor para colores
df$outlier <- as.factor(ifelse(df$outlier == -1, "Outlier", "Normal"))
# Mostrar las primeras filas para verificar
head(df)
ggpairs(df,
columns = 1:6,  # Seleccionar las columnas numéricas
aes(color = outlier, alpha = 0.6),  # Colorear según 'outlier'
upper = list(continuous = wrap("points", size = 2)),  # Gráficos superiores
lower = list(continuous = wrap("points", size = 2)),  # Gráficos inferiores
diag = list(continuous = wrap("densityDiag", alpha = 0.6))) +  # Gráficos de densidad en la diagonal
scale_color_manual(values = c("Normal" = "blue", "Outlier" = "red")) +
labs(title = "Pair Plot de Outliers Detectados por Isolation Forest") +
theme_minimal()
